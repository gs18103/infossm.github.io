---
layout: post
title: "read, write, mmap을 이용한 Fast I/O 구현 (2)"
date: 2025-05-11
author: jinhan814
tags: [algorithm, problem solving]
---

이번 글에서는 이전 글인 [read, write, mmap을 이용한 Fast I/O 구현 (1)](https://infossm.github.io/blog/2025/04/25/fastio-1/)에 이어 Bit-Twiddling Hack을 적용한 더 빠른 입력 기법과 Lookup Table 및 SIMD를 활용한 출력 기법을 살펴보겠습니다.

## 1. Faster Input Implementation

<code>read</code> 또는 <code>mmap</code>을 이용한 빠른 입력 방식은 입력 버퍼를 두고 버퍼 단위로 한 번에 입력을 읽어오며 입력 속도를 향상시킵니다. 대부분의 문제에서는 이 정도 최적화만으로 충분합니다. 다만, 한 번에 여러 문자를 처리할 수 있다면 입력 속도를 더욱 높일 수 있습니다.

### 1.1 8-Byte Block Parsing

앞서 소개한 Fast I/O는 입력 버퍼를 통해 $1$바이트씩 문자를 읽는 방식이었습니다. Bit-Twiddling 기법을 활용하면, $8$바이트 단위로 입력을 가져와 $64$비트 정수 자료형의 비트 연산으로 한 번에 여러 자리 숫자를 처리할 수 있습니다.

```cpp
auto read_int = [&] {
	int ret = 0, flag = 0;
	if (*pr == '-') flag = 1, pr++;
	u64 x = *(u64*)pr ^ 0x3030303030303030;
	if (!(x & 0xf0f0f0f0f0f0f0f0)) {
		x = ((x * 10) + (x >> 8)) & 0x00ff00ff00ff00ff;
		x = ((x * 100) + (x >> 16)) & 0x0000ffff0000ffff;
		x = ((x * 10000) + (x >> 32)) & 0x00000000ffffffff;
		ret = x;
		pr += 8;
	}
	while (*pr & 16) ret = 10 * ret + (*pr++ & 15);
	pr++;
	if (flag) ret = -ret;
	return ret;
};
```

코드에서 <code>\*(u64\*)pr</code>는 <code>pr</code>를 $64$비트 정수 자료형의 포인터로 형변환한 뒤 역참조하며 <code>pr[0]</code>, $\cdots$, <code>pr[7]</code>을 $64$비트 정수 자료형 <code>x</code>에 저장합니다.

이제 ASCII 코드의 성질을 이용하면 <code>x</code>를 구성하는 $8$개의 문자가 모두 숫자인지 여부를 알아낼 수 있습니다.

숫자 <code>'0'</code>, $\cdots$, <code>'9'</code>는 ASCII 코드에서 상위 $4$비트가 항상 <code>0011____</code>로 고정되어 있습니다. 따라서 입력 문자를 <code>0x30 = 0b00110000</code>과 xor 연산하면 각 문자의 상위 $4$비트가 <code>0000____</code>이 됩니다. 즉, <code>'0'</code>는 <code>0x00</code>, <code>'1'</code>는 <code>0x01</code>, $\cdots$, <code>'9'</code>는 <code>0x09</code>로 변환됩니다.

반면, 공백(<code>0x20</code>), 줄바꿈(<code>0x0A</code>), 하이픈(<code>0x2D</code>) 등의 숫자가 아닌 문자는 xor 결과에서 상위 $4$개 비트 중 <code>1</code>인 비트가 남아있습니다. 따라서 xor 결과를 <code>0xf0 = 0b11110000</code>와 bitwise and 연산을 한 뒤 결과가 $0$인지 확인하면 문자가 숫자인지 확인할 수 있습니다. 코드에서는 <code>x & 0xf0f0f0f0f0f0f0f0</code>의 결과가 $0$인지 확인하며 $8$개 문자 중 공백 또는 줄바꿈이 존재하는지 확인합니다.

이제 $8$개 문자가 모두 숫자일 때, 전체 숫자를 이어붙인 값을 빠르게 구하는 과정을 알아보겠습니다.

```cpp
x = ((x * 10) + (x >> 8)) & 0x00ff00ff00ff00ff;
x = ((x * 100) + (x >> 16)) & 0x0000ffff0000ffff;
x = ((x * 10000) + (x >> 32)) & 0x00000000ffffffff;
```

초기 상태에 <code>x</code>에는 $8$개의 숫자가 차례로 저장되어 있습니다. 이를 $2$개씩 묶어서 이어붙이는 과정을 $3$번 반복하면 전체 숫자를 이어붙인 값을 구할 수 있습니다.

첫 번째 줄에서는 $1$바이트씩 숫자를 이어붙입니다. 각 $1$바이트에 저장된 값을 순서대로 $d_0, d_1, \cdots, d_7$이라 합시다. 인접한 두 값 $(d_i, d_{i+1})$은 <code>(x * 10) + (x >> 8)</code>에서 $(10d_i + d_{i+1}, *)$이 되고, <code>0x00ff</code>와 bitwise and 연산을 통해 $(10d_i + d_{i+1}, 0)$이 됩니다. 따라서 첫 번째 줄이 실행되면 $x$의 각 $2$바이트에 두 자리 숫자가 저장됩니다.

비슷하게 두 번째 줄에서는 $2$바이트씩 숫자를 이어붙입니다. 인접한 두 값 $(d_i, d_{i+1})$은 <code>(x * 100) + (x >> 16)</code>에서 $(100d_i + d_{i+1}, 0)$이 되고, <code>0x0000ffff</code>와 bitwise and 연산을 통해 $(100d_i + d_{i + 1}, 0)$이 됩니다.

마지막으로 세 번째 줄에서는 $4$바이트씩 숫자를 이어붙입니다. <code>(x * 10000) + (x >> 32)</code>와 <code>0x00000000ffffffff</code>를 이용하면 $8$바이트에 여덟 자리 숫자가 저장됩니다. 이 값을 정답에 기록한 뒤 <code>pr</code>를 $8$만큼 이동시키면 한 번에 $8$글자를 처리할 수 있습니다.

이후 아직 처리되지 않은 글자를 한 글자씩 순차적으로 읽으며 처리하면 전체 입력을 처리할 수 있습니다.

```cpp
while (*pr & 16) ret = 10 * ret + (*pr++ & 15);
```

사용 예시는 다음과 같습니다. [(코드)](http://boj.kr/839388d8ae634fd68c0cdd1c332aa8b7)

```cpp
auto read_int = [&] {
	int ret = 0, flag = 0;
	if (*pr == '-') flag = 1, pr++;
	u32 x = *(u32*)pr ^ 0x30303030;
	if (!(x & 0xf0f0f0f0)) {
		x = ((x * 10) + (x >> 8)) & 0x00ff00ff;
		x = ((x * 100) + (x >> 16)) & 0x0000ffff;
		ret = x;
		pr += 4;
	}
	while (*pr & 16) ret = 10 * ret + (*pr++ & 15);
	pr++;
	if (flag) ret = -ret;
	return ret;
};
```

비슷하게, $8$바이트 단위 대신 $4$바이트 단위로 숫자를 처리할 수도 있습니다. 이는 입력되는 숫자가 $8$자리 미만인 경우에 유용합니다.

사용 예시는 다음과 같습니다. [(코드)](http://boj.kr/271ea27c0002488293c8ecaebd9dcca6)

### 1.2 Up-to-15-Digit Numbers with 8-4-2-1 Cascade Parsing

```cpp
auto read_int = [&] {
	int ret = 0, flag = 0;
	if (*pr == '-') flag = 1, pr++;
	{
		u64 x = *(u64*)pr ^ 0x3030303030303030;
		if (!(x & 0xf0f0f0f0f0f0f0f0)) {
			x = ((x * 10) + (x >> 8)) & 0x00ff00ff00ff00ff;
			x = ((x * 100) + (x >> 16)) & 0x0000ffff0000ffff;
			x = ((x * 10000) + (x >> 32)) & 0x00000000ffffffff;
			ret = x;
			pr += 8;
		}
	}
	{
		u32 x = *(u32*)pr ^ 0x30303030;
		if (!(x & 0xf0f0f0f0)) {
			x = ((x * 10) + (x >> 8)) & 0x00ff00ff;
			x = ((x * 100) + (x >> 16)) & 0x0000ffff;
			ret = 10000 * ret + x;
			pr += 4;
		}
	}
	{
		u16 x = *(u16*)pr ^ 0x3030;
		if (!(x & 0xf0f0)) {
			x = ((x * 10) + (x >> 8)) & 0x00ff;
			ret = 100 * ret + x;
			pr += 2;
		}
	}
	if (*pr & 16) ret = 10 * ret + (*pr++ & 15);
	pr++;
	if (flag) ret = -ret;
	return ret;
};
```

$8$바이트 단위로 한 번에 여덟 자리 숫자를 처리하는 방법을 응용하면 $8, 4, 2, 1$바이트 단위로 한 번에 여덟 자리, 네 자리, 두 자리, 한 자리 숫자를 처리하며 $4$번의 과정으로 $15$자리 이하의 정수 자료형을 입력받을 수 있습니다.

사용 예시는 다음과 같습니다. [(코드)](http://boj.kr/8f9d056a2d214ef2a73a2bf41cca6bc9)

### 1.3 Up-to-8-Digit Numbers with std::countr_zero

```cpp
auto read_int = [&] {
	u64 x = *(u64*)pr ^ 0x3030303030303030;
	int t = std::countr_zero(x & 0xf0f0f0f0f0f0f0f0) >> 3;
	x <<= 64 - (t << 3);
	x = (x * 10 + (x >> 8)) & 0x00ff00ff00ff00ff;
	x = (x * 100 + (x >> 16)) & 0x0000ffff0000ffff;
	x = (x * 10000 + (x >> 32)) & 0x00000000ffffffff;
	pr += t + 1;
	return x;
};
```

입력되는 정수가 $8$자리 이하라면 <code>std::countr_zero</code>를 이용해 정수를 조건 분기 없이 파싱할 수 있습니다.

<code>pr[0]</code>, $\cdots$, <code>pr[7]</code>, <code>pr[8]</code> 중 숫자가 아닌 문자가 처음으로 등장하는 위치는 <code>x & 0xf0f0f0f0f0f0f0f0</code>에 <code>std::countr_zero</code>를 적용해 알아낼 수 있습니다. <code>std::countr_zero</code>는 <code>numeric</code> 헤더에 정의된 함수로 가장 작은 비트부터 연속한 <code>0</code>의 개수를 반환합니다. 이를 $8$로 나눈 값을 <code>t</code>라 하면 <code>pr[t]</code>는 처음으로 숫자가 아닌 문자가 등장하는 위치가 됩니다.

<code>x <<= 64 - (t << 3)</code>에서는 <code>x</code>에서 <code>pr[t]</code> 이후 부분을 없애고 가장 작은 자릿수의 숫자가 최상위 바이트에 위치하도록 합니다. 이후 $8$바이트 단위로 입력을 가져와 비트 연산으로 숫자를 이어붙이는 방식을 사용하면 $8$자리 이하 정수를 조건 분기 없이 파싱할 수 있습니다.

사용 예시는 다음과 같습니다. [(코드)](http://boj.kr/c82c30fb07b24694af82f88e6ef7b4ca)

```cpp
auto read_int = [&] {
	u32 x = *(u32*)pr ^ 0x30303030;
	int t = std::countr_zero(x & 0xf0f0f0f0) >> 3;
	x <<= 32 - (t << 3);
	x = (x * 10 + (x >> 8)) & 0x00ff00ff;
	x = (x * 100 + (x >> 16)) & 0x0000ffff;
	pr += t + 1;
	return x;
};
```

비슷하게, 입력되는 정수가 $4$자리 이하라면 $32$비트 정수 자료형을 이용해 정수를 조건 분기 없이 파싱할 수 있습니다.

사용 예시는 다음과 같습니다. [(코드)](http://boj.kr/86e284be2de74959bcbef142263ad115)

## 2. Faster Output Implementation

~

### 2.1 4-Digit Lookup Table

```cpp

```

~

사용 예시는 다음과 같습니다. [(코드)]()

### 2.2 SIMD (AVX2) Vectorized Output

```cpp

```

~

사용 예시는 다음과 같습니다. [(코드)]()

## Summary

~

## References

[1] []()